//jetcache:key的组成：area+":"+name+key。
没指定key时，会使用 参数数组 的json结构当成key，没指定key且参数太多，redis会存不下，缓存失败。
key过长问题，实在是简化不了参数的话，我觉得可以手动加个md5属性放方法的参数中，当做key，可以不会过长。
redis的key不能太长，否则会缓存失败。
缓存失效根据key失效，没有按照area或者name范围失效的功能，一个记录更新了，对应的列表无法失效，key不确定，
我都基本不用失效功能，设置短时间自然失效就能抗高并发了。没有范围删除不好做长时间缓存
由于需要存在redis上，方法的返回对象，必须实现序列化
//mq做定时:少了定时器去做业务，用mq且用springboot提供的mq注解，感觉实现好简单、轻量化
//预售:预售商品以预售时间修改为基础逻辑开发，预售时间会经常修改，只要付款在预售时间内，就认为尾款成功。否则根据商品状态判断，未支付的订单第二天支付也会认为尾款支付成功。
//签名机制：也能起到防止重复调用的作用。签名主要传三个header：当前时间戳，uuid，token+时间戳+uuid+传参的md5，到后台时验证md5是否匹配，以及判断uuid是否重复来过滤重复请求。签名是异步的么？
//订单号、退货单号等，制定好规则，承载更多信息，有助于简化sql提升性能
//关于网关：前后台各用一个网关更好
//关于高并发下数据修改问题，比如大量mq消费，修改记录时判断原状态要与当前状态一致，类似于乐观锁，例如：update set name = xxx where id = 1 and status = oldStatus;
//多数据源，mq,rocketmq,mybatis plus，修改售后字段status修改成功却返回失败，boolean update = omsAfterSalesService.update(uw);
原因：sql修改status成功后，其他地方抛异常了，又没加事务注解，mq消费失败，mq重新消费，再次执行sql此时status已修改过，所以修改后返回false了。
总结：没加事务注解，代码其他地方有异常

